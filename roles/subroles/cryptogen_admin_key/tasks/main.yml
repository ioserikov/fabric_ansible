
## roles/cryptogen/tasks/main/yml
## 
## This role is for fabric-ca host  - we using openssl and fabric-ca server
## 
## host fabric-ca has certs from ca and can generate common cryptomaterial
## 
## TODO - repalce by using industrial keys and CAs
## TODO - list of OUs is one for organization!!!! 


- name: private (siginig) key for admin
  openssl_privatekey:
      path: "{{ keystore }}admin_sk.pem"
      size: 4096
      curve: secp256r1
      type: ECC
      force: yes
      # cipher: auto
      select_crypto_backend: cryptography


- name: csr from private key
  openssl_csr:
     privatekey_path: "{{ keystore }}admin_sk.pem"
     path: "{{keystore}}admin_csr"
     state_or_province_name: Moscow Region
     extended_key_usage_critical: true
     force: true # not required. Should the certificate signing request be forced regenerated by this ansible module
     #subject_alt_name: undefined # not required. SAN extension to attach to the certificate signing request,This can either be a 'comma separated string' or a YAML list.,Values should be prefixed by their options. (i.e., C(email), C(URI), C(DNS), C(RID), C(IP), C(dirName), C(otherName) and the ones specific to your CA),More at U(https://tools.ietf.org/html/rfc5280#section-4.2.1.6)
     #basic_constraints: undefined # not required. Indicates basic constraints, such as if the certificate is a CA.
     #subject_alt_name_critical: undefined # not required. Should the subjectAltName extension be considered as critical
     #owner: undefined # not required. Name of the user that should own the file/directory, as would be fed to I(chown).
     key_usage: 
            - digitalSignature
            - keyAgreement 
     common_name: admin@stoloto.ru
     email_address: admin@stoloto.ru
     digest: sha256
     subject: {C: RU, L: Moscow, O: stoloto.ru, OU: lab, CN: admin, emailAddress: admin@stoloto.ru}
     key_usage_critical: true # not required. Should the keyUsage extension be considered as critical
     #extended_key_usage: undefined # not required. Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.,This can either be a 'comma separated string' or a YAML list.
     organizational_unit_name: lab
     unsafe_writes: no # not required. By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted files, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.,This option allows Ansible to fall back to unsafe methods of updating files when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes). IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.
     locality_name: RU
     organization_name: Stoloto
     state: present # not required. choices: present;absent. Whether the certificate signing request should exist or not, taking action if the state is different from what is stated.
     version: 1 # not required. Version of the certificate signing request
     mode: 60447
     country_name: RU
  become: yes   

- name: certificate CA from private-key and csr
  openssl_certificate:
    path: "{{ msp_dir}}admincerts/admin.pem"
    provider: ownca # required. choices: selfsigned;ownca;assertonly;acme. Name of the provider to use to generate/retrieve the OpenSSL certificate. The C(assertonly) provider will not generate files and fail if the certificate file is missing.
    #subject_alt_name_strict: false # not required. If set to True, the I(subject_alt_name) extension field must contain only these values.
    force: true # not required. Generate the certificate, even if it already exists.
    csr_path: "{{keystore}}admin_csr"
    ownca_privatekey_path: "{{fabric_ca_dir}}keystore/ca_sk"
    key_usage: undefined # not required. The I(key_usage) extension field must contain all these values.
    issuer: {C: RU, L: Moscow, O: stoloto.ru, OU: lab, CN: admin, emailAddress: admin@stoloto.ru}
    ownca_version: 3 # not required. Version of the C(ownca) certificate. Nowadays it should almost always be C(3).
    subject_strict: false # not required. If set to True, the I(subject) field must contain only these values.
    selfsigned_version: 3 # not required. Version of the C(selfsigned) certificate. Nowadays it should almost always be C(3).
    unsafe_writes: no # not required. By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted files, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.,This option allows Ansible to fall back to unsafe methods of updating files when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes). IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.
    has_expired: false # not required. Checks if the certificate is expired/not expired at the time the module is executed.
    state: present # not required. choices: present;absent. Whether the certificate should exist or not, taking action if the state is different from what is stated.
    subject: {C: RU, L: Moscow, O: stoloto.ru, OU: lab, CN: admin, emailAddress: admin@stoloto.ru}
    key_usage_strict: false # not required. If set to True, the I(key_usage) extension field must contain only these values.
    subject_alt_name: undefined # not required. The I(subject_alt_name) extension field must contain these values.
    extended_key_usage_strict: false # not required. If set to True, the I(extended_key_usage) extension field must contain only these values.
    privatekey_path: "{{ keystore }}admin_sk.pem"
    #ownca_not_after: undefined # not required. The timestamp at which the certificate stops being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will stop being valid 10 years from now.
    issuer_strict: false # not required. If set to True, the I(issuer) field must contain only these values.
    #ownca_not_before: undefined # not required. The timestamp at which the certificate starts being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will start being valid from now.
    invalid_at: undefined # not required. The certificate must be invalid at this point in time. The timestamp is formatted as an ASN.1 TIME.
    ownca_digest: sha256 # not required. Digest algorithm to be used for the C(ownca) certificate.
    extended_key_usage: undefined # not required. The I(extended_key_usage) extension field must contain all these values.
    not_after: undefined # not required. The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME.
    signature_algorithms: undefined # not required. list of algorithms that you would accept the certificate to be signed with (e.g. ['sha256WithRSAEncryption', 'sha512WithRSAEncryption']).
    selfsigned_not_before: undefined # not required. The timestamp at which the certificate starts being valid. The timestamp is formatted as an ASN.1 TIME. If this value is not specified, certificate will start being valid from now.
    mode: 60447
    ownca_path: "{{ fabric_ca_dir }}ca.pem"
    #valid_in: undefined # not required. The certificate must still be valid in I(valid_in) seconds from now.
    #valid_at: undefined # not required. The certificate must be valid at this point in time. The timestamp is formatted as an ASN.1 TIME.
  become: yes    



